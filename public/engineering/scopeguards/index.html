
<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=52441&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  






  
  
  
    
  





  



<link rel="stylesheet" href="//localhost:52441/scss/main.css" />


<link rel="stylesheet" href="//localhost:52441/custom.css" />

  
<meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
    <meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
  

<title>ScopeGuards | Christopher Weaver</title>


<meta name="author" content="Christopher Weaver">

<meta name="description" content="Portfolio site of Christopher Weaver.">
<link rel="canonical" href="//localhost:52441/engineering/scopeguards/">
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="ScopeGuards">
<meta property="og:description" content="Systems programming languages like C&#43;&#43; do not have a garbage collector and do not utilize automatic reference counting (other than for specific library features) for memory management and therefore require the programmer to ensure memory gets cleaned up throughout the lifecycle of the program. The high price of putting the burden on the engineer to manage their own memory comes with the beneficial tradeoff that you can write much more efficient and predictable programs. C&#43;&#43;, in order to help developers manage memory, uses an idiom called RAII (resource acquisition is initialization), which involves moving memory ownership to objects that will automatically clean up that memory in its destructor once that object falls out of scope. Falling out of scope means the program reaches the ending } in which that object was defined. Modern C&#43;&#43; leans very heavily upon RAII to ensure both performant software and memory-safe programs.">
<meta property="og:url" content="//localhost:52441/engineering/scopeguards/">
<meta property="article:published_time" content="2024-07-11T09:38:32-06:00">
  <meta property="article:modified_time" content="2024-07-11T09:38:32-06:00">
  


  <meta name="og:image" content="//localhost:52441/images/default.png"/>





  
  


  <meta name="twitter:site" content="johndoestwitter">


  <meta name="twitter:creator" content="johndoestwitter">

<meta name="twitter:title" content="ScopeGuards">
<meta name="twitter:description" content="Systems programming languages like C&#43;&#43; do not have a garbage collector and do not utilize automatic reference counting (other than for specific library features) for memory management and therefore require the programmer to ensure memory gets cleaned up throughout the lifecycle of the program. The high price of putting the burden on the engineer to manage their own memory comes with the beneficial tradeoff that you can write much more efficient and predictable programs. C&#43;&#43;, in order to help developers manage memory, uses an idiom called RAII (resource acquisition is initialization), which involves moving memory ownership to objects that will automatically clean up that memory in its destructor once that object falls out of scope. Falling out of scope means the program reaches the ending } in which that object was defined. Modern C&#43;&#43; leans very heavily upon RAII to ensure both performant software and memory-safe programs.">



  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:image" content="//localhost:52441/images/default.png"/>





  


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "Person",
      "@id": "//localhost:52441/#/schema/person/1",
      "name": "Christopher Weaver",
      "url": "//localhost:52441/",
      "image": {
        "@type": "ImageObject",
        "@id": "//localhost:52441/#/schema/image/1",
        "url": "//localhost:52441/images/default.png",
        "width": 453 ,
        "height": 455 ,
        "caption": "Christopher Weaver"
      }
    },
    {
      "@type": "WebSite",
      "@id": "//localhost:52441/#/schema/website/1",
      "url": "//localhost:52441/",
      "name": "Christopher Weaver",
      "description": "Portfolio site of Christopher Weaver.",
      "publisher": {
        "@id": "//localhost:52441/#/schema/person/1"
      }
    },
    {
      "@type": "WebPage",
      "@id": "//localhost:52441/engineering/scopeguards/",
      "url": "//localhost:52441/engineering/scopeguards/",
      "name": "ScopeGuards",
      "description": "Portfolio site of Christopher Weaver.",
      "isPartOf": {
        "@id": "//localhost:52441/#/schema/website/1"
      },
      "about": {
        "@id": "//localhost:52441/#/schema/person/1"
      },
      "datePublished": "2024-07-11T09:38:32-06:00",
      "dateModified": "2024-07-11T09:38:32-06:00",
      "breadcrumb": {
        "@id": "//localhost:52441/engineering/scopeguards/#/schema/breadcrumb/1"
      },
      "primaryImageOfPage": {
        "@id": "//localhost:52441/engineering/scopeguards/#/schema/image/2"
      },
      "inLanguage": "en-US",
      "potentialAction": [{
        "@type": "ReadAction", "target": ["//localhost:52441/engineering/scopeguards/"]
      }]
    },
    {
      "@type": "BreadcrumbList",
      "@id": "//localhost:52441/engineering/scopeguards/#/schema/breadcrumb/1",
      "name": "Breadcrumbs",
      "itemListElement": [{
        "@type": "ListItem",
        "position":  1 ,
        "item": {
          "@type": "WebPage",
          "@id": "//localhost:52441/",
          "url": "//localhost:52441/",
          "name": "Home"
          }
        },{
        "@type": "ListItem",
        "position":  2 ,
        "item": {
          "@type": "WebPage",
          "@id": "//localhost:52441/engineering/",
          "url": "//localhost:52441/engineering/",
          "name": "Engineering"
          }
        },{
        "@type": "ListItem",
        "position":  3 ,
        "item": {
          "@id": "//localhost:52441/engineering/scopeguards/"
          }
        }]
    },
    {
      "@context": "https://schema.org",
      "@graph": [
        {
          "@type": "Article",
          "@id": "//localhost:52441/#/schema/article/1",
          "headline": "ScopeGuards",
          "description": "",
          "isPartOf": {
            "@id": "//localhost:52441/engineering/scopeguards/"
          },
          "mainEntityOfPage": {
            "@id": "//localhost:52441/engineering/scopeguards/"
          },
          "datePublished": "2024-07-11T09:38:32-06:00",
          "dateModified": "2024-07-11T09:38:32-06:00",
          "author": {
            "@id": "//localhost:52441/#/schema/person/1"
          },          
          "publisher": {
            "@id": "//localhost:52441/#/schema/person/1"
          },
          "image": {
            "@id": "//localhost:52441/engineering/scopeguards/#/schema/image/2"
          }
        }
      ]
    },{
      "@context": "https://schema.org",
      "@graph": [
        {
          "@type": "ImageObject",
          "@id": "//localhost:52441/engineering/scopeguards/#/schema/image/2",
          "url": "//localhost:52441/images/default.png",
          "contentUrl": "//localhost:52441/images/default.png",
          "caption": "ScopeGuards"
        }
      ]
    }
  ]
}
</script>
  

  

  
</head><body>
    <header class="container">
  <nav class="main-nav" id="js-navbar">
    <a class="logo" href="//localhost:52441/">Christopher Weaver</a>
    <ul class="menu" id="js-menu">
      
      
      
      <li class="menu-item">
        <span class="menu-link">Work<span class="drop-icon">▾</span></span>
        <ul class="sub-menu">
          
            <li class="menu-item">
              <a href="/projects/" class="menu-link">Projects</a>                  
            </li>
          
            <li class="menu-item">
              <a href="/about/" class="menu-link">About</a>                  
            </li>
          
        </ul>
      </li>
      
      
      
      <li class="menu-item">
        <span class="menu-link">Writing<span class="drop-icon">▾</span></span>
        <ul class="sub-menu">
          
            <li class="menu-item">
              <a href="/posts/" class="menu-link">All Posts</a>                  
            </li>
          
            <li class="menu-item">
              <a href="/engineering/" class="menu-link">Engineering</a>                  
            </li>
          
            <li class="menu-item">
              <a href="/philosophy/" class="menu-link">Philosophy</a>                  
            </li>
          
        </ul>
      </li>
      
      
      
      <li class="menu-item">
        <span class="menu-link">Explore<span class="drop-icon">▾</span></span>
        <ul class="sub-menu">
          
            <li class="menu-item">
              <a href="/categories/" class="menu-link">Categories</a>                  
            </li>
          
            <li class="menu-item">
              <a href="/tags/" class="menu-link">Tags</a>                  
            </li>
          
            <li class="menu-item">
              <a href="/series/" class="menu-link">Series</a>                  
            </li>
          
            <li class="menu-item">
              <a href="/project-types/" class="menu-link">Project Types</a>                  
            </li>
          
        </ul>
      </li>
      
      
      <li class="menu-item--align">
        <div class="switch">
          <input class="switch-input" type="checkbox" id="themeSwitch">
          <label aria-hidden="true" class="switch-label" for="themeSwitch">On</label>
          <div aria-hidden="true" class="switch-marker"></div>
        </div>
      </li>
    </ul>
    <span class="nav-toggle" id="js-navbar-toggle">
      <svg xmlns="http://www.w3.org/2000/svg" id="Outline" viewBox="0 0 24 24" width="30" height="30" fill="var(--color-contrast-high)"><rect y="11" width="24" height="2" rx="1"/><rect y="4" width="24" height="2" rx="1"/><rect y="18" width="24" height="2" rx="1"/></svg>
    </span>
  </nav>
</header><main class="section">
<div class="container">
  <section class="page-header">
    <h1 class="page-header-title">ScopeGuards</h1>
    <div class="post-list-meta">
      <div class="post-list-dates">Jul 11, 2024&nbsp;&middot;&nbsp;6 min.</div>
      
      <div class="post-list-categories">
        
          <a href="//localhost:52441/categories/engineering/">Engineering</a>
        
      </div>
      
      
    </div>
    <p class="page-header-desc"></p>
    <div class="single-terms">
      
      
      <a class="term" href="//localhost:52441/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
      
      <a class="term" href="//localhost:52441/tags/design-patterns/">Design Patterns</a></li>
      
      
    </div>
  </section>
</div>
<div class="single-container-post">
  

  <aside class="toc">
    <div id="js-toc-toggle">
      <h2 class="toc-header">Table of Contents</h2>
      <span class="toc-drop-icon">&blacktriangledown;</span>
    </div>
    <div id="js-toc-contents" class="toc-contents"><nav id="TableOfContents"></nav></div>
  </aside>

  <div class="single-post-contents">
      <div class="series">
        <p>Part of the <a href="//localhost:52441/series/design-patterns/">Design Patterns</a> series:</p>
        
        <ol class="series-list">
        </ol>
      </div>
    
    <div class="single-feature-img">



  

</div>
    <article class="markdown">
        <p>Systems programming languages like C++ do not have a garbage collector and do not utilize automatic reference counting (other than for specific library features) for memory management and therefore require the programmer to ensure memory gets cleaned up throughout the lifecycle of the program. The high price of putting the burden on the engineer to manage their own memory comes with the beneficial tradeoff that you can write much more efficient and predictable programs. C++, in order to help developers manage memory, uses an idiom called RAII (resource acquisition is initialization), which involves moving memory ownership to objects that will automatically clean up that memory in its destructor once that object falls out of scope. Falling out of scope means the program reaches the ending } in which that object was defined. Modern C++ leans very heavily upon RAII to ensure both performant software and memory-safe programs.</p>
<p>RAII is a powerful tool that engineers can use for more than just ensuring memory safety. It also has an interesting side effect that can be leveraged, outside of resource management, to help produce more robust, error-free software. A design pattern that leverages RAII to hedge against runtime errors called the scopeguard. I will be borrowing an example from:</p>
<p><em><strong>Design Patterns With C++</strong></em>
<strong>Author:</strong> <em>Fedor G. Pikus</em></p>
<p>Our example involves some code representing storing records in a database:</p>


  <span class="code-language">C&#43;&#43;</span><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">Record</span> { ... };
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">Database</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">Storage</span> { ... };
</span></span><span style="display:flex;"><span>  Storage S;
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">Index</span> { ... };
</span></span><span style="display:flex;"><span>  Index I;
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">void</span> insert (<span style="color:#6ab825;font-weight:bold">const</span> Record&amp; r);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">void</span> Database::insert(<span style="color:#6ab825;font-weight:bold">const</span> Record&amp; r) {
</span></span><span style="display:flex;"><span>  S.insert(r);
</span></span><span style="display:flex;"><span>  I.insert(r);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We have a database class, as well as an Index and Storage class. When a record is inserted into the database, we need to insert it both into our index and storage class. The problem is that the insert for either of these functions can fail and will throw. If the failure happens on the storage insert, our function cleanly fails, throws, and we can successfully handle that throw elsewhere. But what if the failure happens on the index insert? In this case, we throw out of the function but now we have a problem since the insert on the storage class has already happened and we now do not have synchronization between these two classes.</p>
<p>The obvious answer to this problem is to wrap the entire thing in a try-catch and build a mechanism to revert an insert:</p>


  <span class="code-language">C&#43;&#43;</span><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">void</span> Database::insert(<span style="color:#6ab825;font-weight:bold">const</span> Record&amp; r) {
</span></span><span style="display:flex;"><span>  S.insert(r);
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>    I.insert(r);
</span></span><span style="display:flex;"><span>  } <span style="color:#6ab825;font-weight:bold">catch</span> (...) {
</span></span><span style="display:flex;"><span>    S.undo();
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">throw</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>This works in this use case, but does not scale as more error-prone functionality gets built into the control flow. Even adding one more function to this insert call now requires adding additional complexity that begins to make reasoning about the code difficult. Even something like adding a required finalize function makes things messier:</p>


  <span class="code-language">C&#43;&#43;</span><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">void</span> Database::insert(<span style="color:#6ab825;font-weight:bold">const</span> Record&amp; r) {
</span></span><span style="display:flex;"><span>  S.insert(r);
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>    I.insert(r);
</span></span><span style="display:flex;"><span>  } <span style="color:#6ab825;font-weight:bold">catch</span> (...) {
</span></span><span style="display:flex;"><span>    S.undo();
</span></span><span style="display:flex;"><span>    I.finalize();
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">throw</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  I.finalize();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Modern C++ RAII to the rescue. Let&rsquo;s build a scopeguard to clean up this function and ensure we are robust to failure:</p>


  <span class="code-language">C&#43;&#43;</span><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">ScopeGuardBase</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    ScopeGuardBase() : commit_(<span style="color:#24909d">false</span>) {}
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">void</span> <span style="color:#447fcf">commit</span>() <span style="color:#6ab825;font-weight:bold">const</span> <span style="color:#6ab825;font-weight:bold">noexcept</span> { commit_ = <span style="color:#24909d">true</span>; }
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">protected</span>:
</span></span><span style="display:flex;"><span>    ScopeGuardBase(ScopeGuardBase&amp;&amp; other) : commit_(other.commit_) {
</span></span><span style="display:flex;"><span>      other.commit();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ~ScopeGuardBase() {}
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">mutable</span> <span style="color:#6ab825;font-weight:bold">bool</span> commit_;
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>    ScopeGuardBase&amp; <span style="color:#6ab825;font-weight:bold">operator</span>=(<span style="color:#6ab825;font-weight:bold">const</span> ScopeGuardBase&amp;) = <span style="color:#6ab825;font-weight:bold">delete</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">template</span> &lt;<span style="color:#6ab825;font-weight:bold">typename</span> Func&gt;
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">ScopeGuard</span> : <span style="color:#6ab825;font-weight:bold">public</span> ScopeGuardBase {
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    ScopeGuard(Func&amp;&amp; func) : func_(func) {}
</span></span><span style="display:flex;"><span>    ScopeGuard(<span style="color:#6ab825;font-weight:bold">const</span> Func&amp; func) : func_(func) {}
</span></span><span style="display:flex;"><span>    ~ScopeGuard() { <span style="color:#6ab825;font-weight:bold">if</span> (!commit_) func_(); }
</span></span><span style="display:flex;"><span>    ScopeGuard(ScopeGuard&amp;&amp; other) : ScopeGuardBase(std::move(other)), func_(other.func_) {}
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>    Func func_;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">template</span> &lt;<span style="color:#6ab825;font-weight:bold">typename</span> Func&gt;
</span></span><span style="display:flex;"><span>ScopeGuard&lt;Func&gt; MakeGuard(Func&amp;&amp; func) {
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">return</span> ScopeGuard&lt;Func&gt;(std::forward&lt;Func&gt;(func));
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We now have a scopeguard that is by default &ldquo;armed,&rdquo; which means unless we call the commit() to disarm the scopeguard, it will call the provided function when it goes out of scope. This is perfect for our needs above:</p>


  <span class="code-language">C&#43;&#43;</span><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">void</span> Database::insert(<span style="color:#6ab825;font-weight:bold">const</span> Record&amp; r) {
</span></span><span style="display:flex;"><span>  S.insert(r);
</span></span><span style="display:flex;"><span>  ScopeGuard sg = MakeGuard([&amp;]() { S.undo(); });
</span></span><span style="display:flex;"><span>  I.insert(r);
</span></span><span style="display:flex;"><span>  sg.commit();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Walking through what happens here, we first attempt to insert into Storage. If that fails, no worries, we throw and move on. But if it succeeds, we need to create our scopeguard, passing in our lambda that will call the undo() function on our Storage class. The storage class is by default armed (the class default constructor sets commit to false) so that when the scopeguard goes out of scope, the destructor will be called and the lambda (S.undo()) will be called. This works well since if I.insert() fails and the function throws, the scopeguard is immediately out of scope, the destructor is called and S gets rolled back. But if I.insert() succeeds, we now need to be sure we disarm our scopeguard since we no longer want to roll back the insert on our Storage class when we get out of scope. By calling sg.commit(), we disarm our scopeguard and ensure no rollback occurs.</p>
<p>The syntax is clean and allows for easy additions and modifications, like adding the finalize() back into our function:</p>


  <span class="code-language">C&#43;&#43;</span><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">void</span> Database::insert(<span style="color:#6ab825;font-weight:bold">const</span> Record&amp; r) {
</span></span><span style="display:flex;"><span>  S.insert(r);
</span></span><span style="display:flex;"><span>  ScopeGuard fg = MakeGuard([&amp;]() { S.finalize(); });
</span></span><span style="display:flex;"><span>  ScopeGuard sg = MakeGuard([&amp;]() { S.undo(); });
</span></span><span style="display:flex;"><span>  I.insert(r);
</span></span><span style="display:flex;"><span>  sg.commit();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Here we want fg to always be called after a determination is made on sg since the stack always unwinds from bottom to top once we reach the end of scope. No matter what happens after we create the fg scopeguard, we can rest assured that S.finalize() will be called.</p>
<p>Because we relegate the logic of a scopeguard to the destructor, we need to take a few more precautions than normal. In C++, two exceptions cannot be propagated at the same time, otherwise the program will exit. Because an exception will trigger the destructor of the scope guard, any action we attempt that itself throws an error will possibly bring about a scenario where two exceptions propagate at the same time. To protect against this, we can build a shielded scopeguard:</p>


  <span class="code-language">C&#43;&#43;</span><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">template</span> &lt;<span style="color:#6ab825;font-weight:bold">typename</span> Func&gt;
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">ScopeGuard</span> : <span style="color:#6ab825;font-weight:bold">public</span> ScopeGuardBase {
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    ScopeGuard(Func&amp;&amp; func) : func_(func) {}
</span></span><span style="display:flex;"><span>    ScopeGuard(<span style="color:#6ab825;font-weight:bold">const</span> Func&amp; func) : func_(func) {}
</span></span><span style="display:flex;"><span>    ~ScopeGuard() { 
</span></span><span style="display:flex;"><span>      <span style="color:#6ab825;font-weight:bold">if</span> (!commit_) {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">try</span> { func_(); } <span style="color:#6ab825;font-weight:bold">catch</span> (...) {}
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ScopeGuard(ScopeGuard&amp;&amp; other) : ScopeGuardBase(std::move(other)), func_(other.func_) {}
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>    Func func_;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>If our ScopeGuard destructor throws, we catch it and ensure our program does not prematurely exit.</p>
<p>We can also implement specific logic in the scopeguard destructor based on if its destructor is being triggered due to an exception or not. If we prefer that our scopeguard only implement its function if there are no exceptions propagating the scope, we can do that like this:</p>


  <span class="code-language">C&#43;&#43;</span><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">UncaughtExceptionDetector</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    UncaughtExceptionDetector() : count_(std::uncaught_exceptions()) {}
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">operator</span> <span style="color:#447fcf">bool</span>() <span style="color:#6ab825;font-weight:bold">const</span> <span style="color:#6ab825;font-weight:bold">noexcept</span> { <span style="color:#6ab825;font-weight:bold">return</span> std::uncaught_exceptions() &gt; count_; }
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">const</span> <span style="color:#6ab825;font-weight:bold">int</span> count_;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">template</span> &lt;<span style="color:#6ab825;font-weight:bold">typename</span> Func, <span style="color:#6ab825;font-weight:bold">bool</span> on_success, <span style="color:#6ab825;font-weight:bold">bool</span> on_failure&gt;
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">ScopeGuard</span> : <span style="color:#6ab825;font-weight:bold">public</span> ScopeGuardBase {
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    ScopeGuard(Func&amp;&amp; func) : func_(func) {}
</span></span><span style="display:flex;"><span>    ScopeGuard(<span style="color:#6ab825;font-weight:bold">const</span> Func&amp; func) : func_(func) {}
</span></span><span style="display:flex;"><span>    ~ScopeGuard() { 
</span></span><span style="display:flex;"><span>      <span style="color:#6ab825;font-weight:bold">if</span> ((on_success &amp;&amp; !detector) || (on_failure &amp;&amp; detector)) {
</span></span><span style="display:flex;"><span>        func_();
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ScopeGuard(ScopeGuard&amp;&amp; other) : ScopeGuardBase(std::move(other)), func_(other.func_) {}
</span></span><span style="display:flex;"><span>  <span style="color:#6ab825;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>    UncaughtExceptionDetector detector_;
</span></span><span style="display:flex;"><span>    Func func_;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>std::uncaught_exceptions() returns a number for how many exceptions are currently propagating in the stack. We can conditionally check within the destructor of the scopeguard and modify our behavior accordingly.</p>

    </article>
    <aside>
      <div class="single-terms">
        
          
          <a class="term" href="//localhost:52441/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
          
          <a class="term" href="//localhost:52441/tags/design-patterns/">Design Patterns</a></li>
          
        
      </div>
      
  
  
  

  <section>
    <h2>Share</h2>
    <div class="social-links">
      <ul class="social-icons--share">
        
        
        <a href="https://twitter.com/intent/tweet?url=%2f%2flocalhost%3a52441%2fengineering%2fscopeguards%2f&amp;text=ScopeGuards" target="_blank" rel="noopener" aria-label="Share on Twitter" class="social-btn twitter">
          <li><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-twitter" width="24" height="24" viewBox="0 0 384 312" fill="var(--color-primary)"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5 0-78.8 35.3-78.8 78.8 0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3-6.7 11.6-10.6 25.2-10.6 39.6 0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1 0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4 0-12.6-.4-18.8-1.1 34.9 22.4 76.3 35.4 120.8 35.4 144.9 0 224.1-120 224.1-224.1 0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg></li>
        </a>
        
        
        
        
        
        
        
        <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2f%2flocalhost%3a52441%2fengineering%2fscopeguards%2f&amp;source=%2f%2flocalhost%3a52441%2fengineering%2fscopeguards%2f&amp;title=ScopeGuards&amp;summary=ScopeGuards" target="_blank" rel="noopener" aria-label="Share on LinkedIn" class="social-btn linkedin">
          <li><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-linkedin" width="24" height="24" viewBox="0 0 352 352" fill="var(--color-primary)"><path d="M0,40v272c0,21.9,18.1,40,40,40h272c21.9,0,40-18.1,40-40V40c0-21.9-18.1-40-40-40H40C18.1,0,0,18.1,0,40z M312,32 c4.6,0,8,3.4,8,8v272c0,4.6-3.4,8-8,8H40c-4.6,0-8-3.4-8-8V40c0-4.6,3.4-8,8-8H312z M59.5,87c0,15.2,12.3,27.5,27.5,27.5 c15.2,0,27.5-12.3,27.5-27.5c0-15.2-12.3-27.5-27.5-27.5C71.8,59.5,59.5,71.8,59.5,87z M187,157h-1v-21h-45v152h47v-75 c0-19.8,3.9-39,28.5-39c24.2,0,24.5,22.4,24.5,40v74h47v-83.5c0-40.9-8.7-72-56.5-72C208.5,132.5,193.3,145.1,187,157z M64,288h47.5 V136H64V288z"/></svg></li>
        </a>
        
        
        
        <a href="mailto:?subject=Christopher%20Weaver%20-%20ScopeGuards.&amp;body=ScopeGuards%2c%20by%20Christopher%20Weaver%0a%0a%0a%2f%2flocalhost%3a52441%2fengineering%2fscopeguards%2f%0a" target="_blank" class="social-btn email">
          <li><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-mail" width="24" height="24" viewBox="0 0 416 288" fill="var(--color-primary)"><path d="m0 16v256 16h16 384 16v-16-256-16h-16-384-16zm347 16-139 92.5-139-92.5zm-148 125.5 9 5.5 9-5.5 167-111.5v210h-352v-210z"/></svg></li>
        </a>
      </ul>
    </div>
  </section>
  
        <div class="series">
          <p>Part of the <a href="//localhost:52441/series/design-patterns/">Design Patterns</a> series:</p>
          
          <ol>
          </ol>
        </div>
      
      
    </aside>
  </div>
</div>

    </main><footer>
  
  <div class="section footer">
    <p class="footer-copyright">&copy; 2025 &middot; 
      <a href="//localhost:52441/">Christopher Weaver</a>
      
    </p>
    
      <div class="footer-socials">
        
<div class="social-links">
  <ul class="social-icons">
    
    

    
    

    
    
    <li>
      <a href="https://github.com/crweaver225" target="_blank" rel="noopener" aria-label="Visit Github profile" class="social-btn github">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-github" width="24" height="24" viewBox="0 0 24 24" fill="var(--color-primary)"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
      </a>
    </li>
    

    
    

    
    
    <li>
      <a href="https://www.linkedin.com/in/christopher-weaver" target="_blank" rel="noopener" aria-label="Visit LinkedIn profile" class="social-btn linkedin">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-linkedin" width="24" height="24" viewBox="0 0 352 352" fill="var(--color-primary)"><path d="M0,40v272c0,21.9,18.1,40,40,40h272c21.9,0,40-18.1,40-40V40c0-21.9-18.1-40-40-40H40C18.1,0,0,18.1,0,40z M312,32 c4.6,0,8,3.4,8,8v272c0,4.6-3.4,8-8,8H40c-4.6,0-8-3.4-8-8V40c0-4.6,3.4-8,8-8H312z M59.5,87c0,15.2,12.3,27.5,27.5,27.5 c15.2,0,27.5-12.3,27.5-27.5c0-15.2-12.3-27.5-27.5-27.5C71.8,59.5,59.5,71.8,59.5,87z M187,157h-1v-21h-45v152h47v-75 c0-19.8,3.9-39,28.5-39c24.2,0,24.5,22.4,24.5,40v74h47v-83.5c0-40.9-8.7-72-56.5-72C208.5,132.5,193.3,145.1,187,157z M64,288h47.5 V136H64V288z"/></svg>
        </a>
    </li>
    

    
    
    <li>
      <a href="mailto:?to=crweaver225%40yahoo.com" target="_blank" class="social-btn email">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-mail" width="24" height="24" viewBox="0 0 416 288" fill="var(--color-primary)"><path d="m0 16v256 16h16 384 16v-16-256-16h-16-384-16zm347 16-139 92.5-139-92.5zm-148 125.5 9 5.5 9-5.5 167-111.5v210h-352v-210z"/></svg>
      </a>
    </li>
    
  </ul>
</div>

      </div>
    
  </div>
</footer>
  
  





  
  
  
    <script src="//localhost:52441/custom.js"></script>
  




  

<script src="//localhost:52441/main.js"></script>


</body>
</html>
