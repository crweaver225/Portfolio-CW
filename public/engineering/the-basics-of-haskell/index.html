
<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=52225&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  






  
  
  
    
  





  



<link rel="stylesheet" href="//localhost:52225/scss/main.css" />


<link rel="stylesheet" href="//localhost:52225/custom.css" />

  
<meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
    <meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
  

<title>The Basics of Haskell | Christopher Weaver</title>


<meta name="author" content="Christopher Weaver">

<meta name="description" content="Portfolio site of Christopher Weaver.">
<link rel="canonical" href="//localhost:52225/engineering/the-basics-of-haskell/">
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="The Basics of Haskell">
<meta property="og:description" content="Haskell is a unique beast. As a purely functional programming language it has vastly different benefits to offer over procedural and object oriented programming languages. The language requires a different way of thinking for the one programming in it. It demands significantly more of an initial cognitive load to learn compared to languages like Python, Javascript, and Rust which all tinker around the edges of each other as far as syntax goes. This requirement will put off many to the language and largely explains how little it has been adopted in the market, but the other side of the coin is that Haskell offers a different paradigm that can be significantly easier to reason about. Clear and concise syntax meets software largely devoid of hidden states that often produce bugs and unpredictable runtimes. Haskell makes writting concurrent code trivial, allows for better code reuse, and is optimal for test driven development. But in order to unlock these benefits, it is important to first get a grasp of the basics of the language.">
<meta property="og:url" content="//localhost:52225/engineering/the-basics-of-haskell/">
<meta property="article:published_time" content="2025-02-20T09:38:32-06:00">
  <meta property="article:modified_time" content="2025-02-20T09:38:32-06:00">
  

<meta property="og:image" content="//localhost:52225/engineering/the-basics-of-haskell/haskell.png"/>
  





  <meta property="og:see_also" content="//localhost:52225/engineering/creating-new-types-in-haskell/" /><meta property="og:see_also" content="//localhost:52225/engineering/lazy-evaluation-in-haskell/" />
  


  <meta name="twitter:site" content="johndoestwitter">


  <meta name="twitter:creator" content="johndoestwitter">

<meta name="twitter:title" content="The Basics of Haskell">
<meta name="twitter:description" content="Haskell is a unique beast. As a purely functional programming language it has vastly different benefits to offer over procedural and object oriented programming languages. The language requires a different way of thinking for the one programming in it. It demands significantly more of an initial cognitive load to learn compared to languages like Python, Javascript, and Rust which all tinker around the edges of each other as far as syntax goes. This requirement will put off many to the language and largely explains how little it has been adopted in the market, but the other side of the coin is that Haskell offers a different paradigm that can be significantly easier to reason about. Clear and concise syntax meets software largely devoid of hidden states that often produce bugs and unpredictable runtimes. Haskell makes writting concurrent code trivial, allows for better code reuse, and is optimal for test driven development. But in order to unlock these benefits, it is important to first get a grasp of the basics of the language.">


<meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:image" content="//localhost:52225/engineering/the-basics-of-haskell/haskell.png"/>
  





  


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "Person",
      "@id": "//localhost:52225/#/schema/person/1",
      "name": "Christopher Weaver",
      "url": "//localhost:52225/",
      "image": {
        "@type": "ImageObject",
        "@id": "//localhost:52225/#/schema/image/1",
        "url": "//localhost:52225/images/default.png",
        "width": 453 ,
        "height": 455 ,
        "caption": "Christopher Weaver"
      }
    },
    {
      "@type": "WebSite",
      "@id": "//localhost:52225/#/schema/website/1",
      "url": "//localhost:52225/",
      "name": "Christopher Weaver",
      "description": "Portfolio site of Christopher Weaver.",
      "publisher": {
        "@id": "//localhost:52225/#/schema/person/1"
      }
    },
    {
      "@type": "WebPage",
      "@id": "//localhost:52225/engineering/the-basics-of-haskell/",
      "url": "//localhost:52225/engineering/the-basics-of-haskell/",
      "name": "The Basics of Haskell",
      "description": "Portfolio site of Christopher Weaver.",
      "isPartOf": {
        "@id": "//localhost:52225/#/schema/website/1"
      },
      "about": {
        "@id": "//localhost:52225/#/schema/person/1"
      },
      "datePublished": "2025-02-20T09:38:32-06:00",
      "dateModified": "2025-02-20T09:38:32-06:00",
      "breadcrumb": {
        "@id": "//localhost:52225/engineering/the-basics-of-haskell/#/schema/breadcrumb/1"
      },
      "primaryImageOfPage": {
        "@id": "//localhost:52225/engineering/the-basics-of-haskell/#/schema/image/2"
      },
      "inLanguage": "en-US",
      "potentialAction": [{
        "@type": "ReadAction", "target": ["//localhost:52225/engineering/the-basics-of-haskell/"]
      }]
    },
    {
      "@type": "BreadcrumbList",
      "@id": "//localhost:52225/engineering/the-basics-of-haskell/#/schema/breadcrumb/1",
      "name": "Breadcrumbs",
      "itemListElement": [{
        "@type": "ListItem",
        "position":  1 ,
        "item": {
          "@type": "WebPage",
          "@id": "//localhost:52225/",
          "url": "//localhost:52225/",
          "name": "Home"
          }
        },{
        "@type": "ListItem",
        "position":  2 ,
        "item": {
          "@type": "WebPage",
          "@id": "//localhost:52225/engineering/",
          "url": "//localhost:52225/engineering/",
          "name": "Engineering"
          }
        },{
        "@type": "ListItem",
        "position":  3 ,
        "item": {
          "@id": "//localhost:52225/engineering/the-basics-of-haskell/"
          }
        }]
    },
    {
      "@context": "https://schema.org",
      "@graph": [
        {
          "@type": "Article",
          "@id": "//localhost:52225/#/schema/article/1",
          "headline": "The Basics of Haskell",
          "description": "",
          "isPartOf": {
            "@id": "//localhost:52225/engineering/the-basics-of-haskell/"
          },
          "mainEntityOfPage": {
            "@id": "//localhost:52225/engineering/the-basics-of-haskell/"
          },
          "datePublished": "2025-02-20T09:38:32-06:00",
          "dateModified": "2025-02-20T09:38:32-06:00",
          "author": {
            "@id": "//localhost:52225/#/schema/person/1"
          },          
          "publisher": {
            "@id": "//localhost:52225/#/schema/person/1"
          },
          "image": {
            "@id": "//localhost:52225/engineering/the-basics-of-haskell/#/schema/image/2"
          }
        }
      ]
    },{
      "@context": "https://schema.org",
      "@graph": [
        {
          "@type": "ImageObject",
          "@id": "//localhost:52225/engineering/the-basics-of-haskell/#/schema/image/2",
          "url": "//localhost:52225/engineering/the-basics-of-haskell/haskell.png",
          "contentUrl": "//localhost:52225/engineering/the-basics-of-haskell/haskell.png",
          "caption": "The Basics of Haskell"
        }
      ]
    }
  ]
}
</script>
  

  

  
</head><body>
    <header class="container">
  <nav class="main-nav" id="js-navbar">
    <a class="logo" href="//localhost:52225/">Christopher Weaver</a>
    <ul class="menu" id="js-menu">
      
      
      
      <li class="menu-item">
        <span class="menu-link">Work<span class="drop-icon">▾</span></span>
        <ul class="sub-menu">
          
            <li class="menu-item">
              <a href="/projects/" class="menu-link">Projects</a>                  
            </li>
          
            <li class="menu-item">
              <a href="/about/" class="menu-link">About</a>                  
            </li>
          
        </ul>
      </li>
      
      
      
      <li class="menu-item">
        <span class="menu-link">Writing<span class="drop-icon">▾</span></span>
        <ul class="sub-menu">
          
            <li class="menu-item">
              <a href="/posts/" class="menu-link">All Posts</a>                  
            </li>
          
            <li class="menu-item">
              <a href="/engineering/" class="menu-link">Engineering</a>                  
            </li>
          
            <li class="menu-item">
              <a href="/philosophy/" class="menu-link">Philosophy</a>                  
            </li>
          
        </ul>
      </li>
      
      
      
      <li class="menu-item">
        <span class="menu-link">Explore<span class="drop-icon">▾</span></span>
        <ul class="sub-menu">
          
            <li class="menu-item">
              <a href="/categories/" class="menu-link">Categories</a>                  
            </li>
          
            <li class="menu-item">
              <a href="/tags/" class="menu-link">Tags</a>                  
            </li>
          
            <li class="menu-item">
              <a href="/series/" class="menu-link">Series</a>                  
            </li>
          
            <li class="menu-item">
              <a href="/project-types/" class="menu-link">Project Types</a>                  
            </li>
          
        </ul>
      </li>
      
      
      <li class="menu-item--align">
        <div class="switch">
          <input class="switch-input" type="checkbox" id="themeSwitch">
          <label aria-hidden="true" class="switch-label" for="themeSwitch">On</label>
          <div aria-hidden="true" class="switch-marker"></div>
        </div>
      </li>
    </ul>
    <span class="nav-toggle" id="js-navbar-toggle">
      <svg xmlns="http://www.w3.org/2000/svg" id="Outline" viewBox="0 0 24 24" width="30" height="30" fill="var(--color-contrast-high)"><rect y="11" width="24" height="2" rx="1"/><rect y="4" width="24" height="2" rx="1"/><rect y="18" width="24" height="2" rx="1"/></svg>
    </span>
  </nav>
</header><main class="section">
<div class="container">
  <section class="page-header">
    <h1 class="page-header-title">The Basics of Haskell</h1>
    <div class="post-list-meta">
      <div class="post-list-dates">Feb 20, 2025&nbsp;&middot;&nbsp;9 min.</div>
      
      <div class="post-list-categories">
        
          <a href="//localhost:52225/categories/engineering/">Engineering</a>
        
      </div>
      
      
    </div>
    <p class="page-header-desc"></p>
    <div class="single-terms">
      
      
      <a class="term" href="//localhost:52225/tags/haskell/">Haskell</a></li>
      
      
    </div>
  </section>
</div>
<div class="single-container-post">
  

  <aside class="toc">
    <div id="js-toc-toggle">
      <h2 class="toc-header">Table of Contents</h2>
      <span class="toc-drop-icon">&blacktriangledown;</span>
    </div>
    <div id="js-toc-contents" class="toc-contents"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#declarations-and-variables">Declarations and Variables</a></li>
        <li><a href="#primitive-types">Primitive Types</a></li>
        <li><a href="#arithmetic">Arithmetic</a></li>
        <li><a href="#functions">Functions</a></li>
        <li><a href="#guard-statements">Guard Statements</a></li>
        <li><a href="#pairs">Pairs</a></li>
        <li><a href="#lists">Lists</a></li>
        <li><a href="#lambdas">Lambdas</a></li>
        <li><a href="#pattern-matching">Pattern Matching</a></li>
        <li><a href="#list-comprehension">List Comprehension</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
  </aside>

  <div class="single-post-contents">
      <div class="series">
        <p>Part of the <a href="//localhost:52225/series/haskell/">Haskell</a> series:</p>
        
        <ol class="series-list">
            <li>The Basics of Haskell<span class="series-this-post">This post!</span>
              
            </li>
            <li>
                <a href="//localhost:52225/engineering/lazy-evaluation-in-haskell/">Lazy Evaluation in Haskell</a>
              
            </li>
            <li>
                <a href="//localhost:52225/engineering/creating-new-types-in-haskell/">Creating New Types in Haskell</a>
              
            </li>
        </ol>
      </div>
    
    <div class="single-feature-img">



  


<img class="feature-image" 
     srcset="/engineering/the-basics-of-haskell/haskell.png 480w, /engineering/the-basics-of-haskell/haskell.png 800w"
     sizes="(max-width: 600px) 480px, 800px"
     src="/engineering/the-basics-of-haskell/haskell.png"
     alt="Feature image">
</div>
    <article class="markdown">
        <p>Haskell is a unique beast. As a purely functional programming language it has vastly different benefits to offer over procedural and object oriented programming languages. The language requires a different way of thinking for the one programming in it. It demands significantly more of an initial cognitive load to learn compared to languages like Python, Javascript, and Rust which all tinker around the edges of each other as far as syntax goes. This requirement will put off many to the language and largely explains how little it has been adopted in the market, but the other side of the coin is that Haskell offers a different paradigm that can be significantly easier to reason about. Clear and concise syntax meets software largely devoid of hidden states that often produce bugs and unpredictable runtimes. Haskell makes writting concurrent code trivial, allows for better code reuse, and is optimal for test driven development. But in order to unlock these benefits, it is important to first get a grasp of the basics of the language.</p>
<h3 id="declarations-and-variables">Declarations and Variables<a href="#declarations-and-variables">
    <svg role="img" aria-labelledby="declarations-and-variables-IconTitle" fill="var(--color-primary)" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg">
      <title id="declarations-and-variables-IconTitle">Link to this heading</title>
      <path d="M0 0h24v24H0z" fill="none"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg>
  </a>
</h3>

  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span></span></span></code></pre></div>
<p>We have just created an integer value and assigned 3 to it. Perhaps not the most exciting thing ever at first glance, but in reality we have already come across the first interesting idiosyncrasy of Haskell. The following code will fail to compile with an error:</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span></span></span></code></pre></div>
<p>The secret sauce of Haskell is that it is a purely functional programming langauge that puts heavy emphasis upon non-mutable states. Once we assign x to be 3, it will be that value forever. In Haskell, variables are not mutable boxes, they are just names for values.</p>
<h3 id="primitive-types">Primitive Types<a href="#primitive-types">
    <svg role="img" aria-labelledby="primitive-types-IconTitle" fill="var(--color-primary)" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg">
      <title id="primitive-types-IconTitle">Link to this heading</title>
      <path d="M0 0h24v24H0z" fill="none"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg>
  </a>
</h3><p>The primitive types that come with Haskell include:
Bool - logical values
Char - single character
String - list of characters
Int - fixed precision integers
Integer = arbitrary-precision integers (generally 64 bit)
Float - single-precision floating point number
Double - double-precision floating point number</p>
<h3 id="arithmetic">Arithmetic<a href="#arithmetic">
    <svg role="img" aria-labelledby="arithmetic-IconTitle" fill="var(--color-primary)" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg">
      <title id="arithmetic-IconTitle">Link to this heading</title>
      <path d="M0 0h24v24H0z" fill="none"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg>
  </a>
</h3>

  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">example1</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">example2</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#a6e22e">example3</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4.3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">12.2</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span><span style="color:#a6e22e">example4</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">5.7</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">3.2</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span><span style="color:#a6e22e">example5</span> <span style="color:#f92672">=</span> mod <span style="color:#ae81ff">17</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span><span style="color:#a6e22e">example6</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">17</span> `mod` <span style="color:#ae81ff">3</span></span></span></code></pre></div>
<p>The most interesting are the last two examples. In place of the % symbol used to peform modulos operations in other languages, Haskell uses the mod keyword. Mod is represented as a function in Haskell which means the natural way of computing the operation is to type out the function first, followed by its arguments. But Haskell does allow us a different way that many would argue is more readable, which is to type your first argument, places mod between <code>backticks</code> and then add your second argument.</p>
<h3 id="functions">Functions<a href="#functions">
    <svg role="img" aria-labelledby="functions-IconTitle" fill="var(--color-primary)" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg">
      <title id="functions-IconTitle">Link to this heading</title>
      <path d="M0 0h24v24H0z" fill="none"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg>
  </a>
</h3><p>As a functional programming language, this section is probably a must to have. Lets define a function that sums two values together</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">sumValues</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Integer</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Integer</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">sumValues</span> n m <span style="color:#f92672">=</span> n <span style="color:#f92672">+</span> m</span></span></code></pre></div>
<p>The first line is a definition of our sumValues function. It gives a name to the function, tells us that it takes in one argument in the form of an Integer and returns an Integer. The second line is the implementation details of the function. We can now use this function</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> sumvalues <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">20</span></span></span></code></pre></div>
<p>The values for a will be 30.</p>
<p>Because Haskell does not offer the same loop syntax as other langauges, recursion is a major aspect of the build process. Recursive functions tend to work like so</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">sumtorial</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Integer</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Integer</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">sumtorial</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#a6e22e">sumtorial</span> n <span style="color:#f92672">=</span> n <span style="color:#f92672">+</span> sumtorial( n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span><span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> print (sumtorial <span style="color:#ae81ff">10</span>)</span></span></code></pre></div>
<p>Breaking this down, we define our function to take in one integer and return one integer. We also specify on the second line what the implementation of sumtorial should be when passed a zero specifically, this becomes our break case where the function ends calling itself. Finally we have our other impelementation that takes any value other than zero and adds it to a recusrive call to itself.</p>
<h3 id="guard-statements">Guard Statements<a href="#guard-statements">
    <svg role="img" aria-labelledby="guard-statements-IconTitle" fill="var(--color-primary)" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg">
      <title id="guard-statements-IconTitle">Link to this heading</title>
      <path d="M0 0h24v24H0z" fill="none"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg>
  </a>
</h3><p>Functions can utilize an arbitrary number of guard statements that get evaluated from top to bottom one at a time. Once a guard statement gets evaluated to True, its associated code gets executed</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">hailstone</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Integer</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Integer</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">hailstone</span> n
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span>  <span style="color:#f92672">|</span> n `mod` <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">=</span> n `div` <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span>  <span style="color:#f92672">|</span> otherwise      <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span><span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> print ( hailstone <span style="color:#ae81ff">3</span> )</span></span></code></pre></div>
<p>A guard statement starts with the | character where what follows get evaluated as a boolean. In this case, if n divided by two does not have a remainder then hailstone will execute the value n divided by two. If the first guard statement evaluates to false, we move to the second guard statement <em>otherwise</em> which is a alias for True and will always get executed if control flow reaches it.</p>
<h3 id="pairs">Pairs<a href="#pairs">
    <svg role="img" aria-labelledby="pairs-IconTitle" fill="var(--color-primary)" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg">
      <title id="pairs-IconTitle">Link to this heading</title>
      <path d="M0 0h24v24H0z" fill="none"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg>
  </a>
</h3><p>We can pair things together nicely like so</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">q</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Int</span>, <span style="color:#66d9ef">Char</span>)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">q</span> <span style="color:#f92672">=</span> (<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#39;x&#39;</span>)</span></span></code></pre></div>
<p>This can nicely get folded into our functions like so</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">sumPair</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Int</span>, <span style="color:#66d9ef">Int</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">sumPair</span> (x,y) <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span><span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> print (sumPair(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>))</span></span></code></pre></div>
<h3 id="lists">Lists<a href="#lists">
    <svg role="img" aria-labelledby="lists-IconTitle" fill="var(--color-primary)" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg">
      <title id="lists-IconTitle">Link to this heading</title>
      <path d="M0 0h24v24H0z" fill="none"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg>
  </a>
</h3><p>Declaring an empty list looks like this</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">emptyList</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">[]</span></span></span></code></pre></div>
<p>and explicit lists can be declared like this</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>]</span></span></code></pre></div>
<p>but often lists are built up from an empty list using the <em>cons</em> operator :. Cons takes an element and a list and produces a new list with the element prepended to the front like so</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">:</span> <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">:</span> <span style="color:#ae81ff">4</span> <span style="color:#66d9ef">:</span> <span style="color:#66d9ef">[]</span></span></span></code></pre></div>
<p>In this scenario, b is now [2,3,4]. We often seen this leveraged in functions</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">hailstoneSequence</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Integer</span> <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">Integer</span>]
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">hailstoneSequence</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#a6e22e">hailstoneSequence</span> n <span style="color:#f92672">=</span> n <span style="color:#66d9ef">:</span> hailstoneSequence (hailstone n)</span></span></code></pre></div>
<p>This will construct a list with the first value being n and the next value being whatever hailstone of n returns. The final value will be 1 as we defined that break case for our recursion.</p>
<p>Another important aspect of Haskell is how it handles traversing lists. Take a look at this example that computes the length of a list</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">intListLength</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">Integer</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Integer</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">intListLength</span> <span style="color:#66d9ef">[]</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#a6e22e">intListLength</span> (x<span style="color:#66d9ef">:</span>xs) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> intListLength xs
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span><span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> print (intListLength [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>])</span></span></code></pre></div>
<p>The most important part here is the (x:xs) which acts as a xcons which means x is the first element in the list and xs is the rest of the elements. By continually passing xs to intListLength, we continue to strip values from the list until it is empty where our break case returns zero. Each recursive call returns + 1 to help us get the final count for the lenght of the list. For best practice, since we do no computations with x, we could replace it with an _ in this case making it (_:xs).</p>
<h3 id="lambdas">Lambdas<a href="#lambdas">
    <svg role="img" aria-labelledby="lambdas-IconTitle" fill="var(--color-primary)" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg">
      <title id="lambdas-IconTitle">Link to this heading</title>
      <path d="M0 0h24v24H0z" fill="none"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg>
  </a>
</h3><p>An alternative to defining functions as equations is to define them as lambdas. Lambda expressions are composed of a pattern for each of the arguments and a body that specifies how the result can be calculated in terms of the arguments. Just like in other langauges, Haskell lambdas are nameless functions. An example of a lambda that takes a single number x as its argument and produces the result x + x would look like:</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span> <span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> x <span style="color:#f92672">+</span> x</span></span></code></pre></div>
<p>In use, this can look like</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span>(<span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> x <span style="color:#f92672">+</span> x) <span style="color:#ae81ff">2</span></span></span></code></pre></div>
<p>which would evaluate to 4. Often lambdas are incorporated into other functions like map</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">main</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> ()
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> print (map (<span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> x <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>])</span></span></code></pre></div>
<h3 id="pattern-matching">Pattern Matching<a href="#pattern-matching">
    <svg role="img" aria-labelledby="pattern-matching-IconTitle" fill="var(--color-primary)" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg">
      <title id="pattern-matching-IconTitle">Link to this heading</title>
      <path d="M0 0h24v24H0z" fill="none"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg>
  </a>
</h3><p>In Haskell, pattern matching is a powerful feature that allows for the destructuring and matching of values against specific functional patterns, which can greatly simplify code and improve readability. Consider a function to compute the factorial of a value, we could use conditional statements:</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">factorial</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">factorial</span> n <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> n <span style="color:#f92672">*</span> factorial (n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)</span></span></code></pre></div>
<p>This works correctly, but is significantly more challenging to read than this version that uses pattern matching</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">factorial</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">factorial</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#a6e22e">factorial</span> n <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> factorial (n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)</span></span></code></pre></div>
<p>Pattern matching is executed linearly from top to bottom. If the argument zero is passed into the function, it will execute the top option and return one. If we switched these two cases up, factorial 0 = 1 would never execute since it would also match the other option. This is generally the best option for handling stop cases during recursion.</p>
<p>Pattern matching also can take wildcard values which signal to Haskell that we do not care what is passed in there. This can be helpful when handling multiple arguments:</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">describeList</span> <span style="color:#f92672">::</span> [a] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">String</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">describeList</span> <span style="color:#66d9ef">[]</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Empty List&#34;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#a6e22e">describeList</span> (<span style="color:#66d9ef">_</span><span style="color:#66d9ef">:[]</span>) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Single element list&#34;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span><span style="color:#a6e22e">describeList</span> (<span style="color:#66d9ef">_</span>,<span style="color:#66d9ef">_</span>,<span style="color:#66d9ef">_</span>) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Multiple elements&#34;</span></span></span></code></pre></div>
<p>In the third example, we tell Haskell to ignore the first value in the tuple and just check to see if the second argument might be an empty list. We can use pattern matching to filter out invariants and write clean functions that do not need to worry about certain cases since they were already filtered out during the pattern matching phase.</p>
<h3 id="list-comprehension">List Comprehension<a href="#list-comprehension">
    <svg role="img" aria-labelledby="list-comprehension-IconTitle" fill="var(--color-primary)" height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg">
      <title id="list-comprehension-IconTitle">Link to this heading</title>
      <path d="M0 0h24v24H0z" fill="none"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg>
  </a>
</h3><p>Generators help Haskell iterate through a list to generate a new list that has been transformed or modified in some way. This is called list comprehension and takes the form</p>
<p>[ expression | generator, filter ]</p>
<p>Expression: Defines what each element in the list will look like
Generator: Specifies how to produce elements
Filter (optional) : Restricts what elements make the final list</p>
<p>Lets build a function that takes a list of numbers and returns a new list where each number has been squared</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">squares</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">Int</span>] <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">Int</span>]
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">squares</span> ns <span style="color:#f92672">=</span> [x <span style="color:#f92672">*</span> x <span style="color:#f92672">|</span> x <span style="color:#f92672">&lt;-</span> xs]</span></span></code></pre></div>
<p>This reads for each element x in xs, our new list should insert a new value of x * x. If, lets say, we only want elements in our new list that are even values, we add our filter</p>


  <span class="code-language">Haskell</span><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Haskell" data-lang="Haskell"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">evenSquares</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">Int</span>] <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">Int</span>]
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#a6e22e">evenSquares</span> xs <span style="color:#f92672">=</span> [x <span style="color:#f92672">*</span> x <span style="color:#f92672">|</span> x <span style="color:#f92672">&lt;-</span> xs, even x]</span></span></code></pre></div>
<p>What takes place after the generator and comma is the filter that determines if the first part of our list comprehension (x*x) will get executed for this element. If the filter evalutes to false, then the value is ignored and the generator moves on to the next element.</p>

    </article>
    <aside>
      <div class="single-terms">
        
          
          <a class="term" href="//localhost:52225/tags/haskell/">Haskell</a></li>
          
        
      </div>
      
  
  
  

  <section>
    <h2>Share</h2>
    <div class="social-links">
      <ul class="social-icons--share">
        
        
        <a href="https://twitter.com/intent/tweet?url=%2f%2flocalhost%3a52225%2fengineering%2fthe-basics-of-haskell%2f&amp;text=The%20Basics%20of%20Haskell" target="_blank" rel="noopener" aria-label="Share on Twitter" class="social-btn twitter">
          <li><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-twitter" width="24" height="24" viewBox="0 0 384 312" fill="var(--color-primary)"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5 0-78.8 35.3-78.8 78.8 0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3-6.7 11.6-10.6 25.2-10.6 39.6 0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1 0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4 0-12.6-.4-18.8-1.1 34.9 22.4 76.3 35.4 120.8 35.4 144.9 0 224.1-120 224.1-224.1 0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg></li>
        </a>
        
        
        
        
        
        
        
        <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2f%2flocalhost%3a52225%2fengineering%2fthe-basics-of-haskell%2f&amp;source=%2f%2flocalhost%3a52225%2fengineering%2fthe-basics-of-haskell%2f&amp;title=The%20Basics%20of%20Haskell&amp;summary=The%20Basics%20of%20Haskell" target="_blank" rel="noopener" aria-label="Share on LinkedIn" class="social-btn linkedin">
          <li><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-linkedin" width="24" height="24" viewBox="0 0 352 352" fill="var(--color-primary)"><path d="M0,40v272c0,21.9,18.1,40,40,40h272c21.9,0,40-18.1,40-40V40c0-21.9-18.1-40-40-40H40C18.1,0,0,18.1,0,40z M312,32 c4.6,0,8,3.4,8,8v272c0,4.6-3.4,8-8,8H40c-4.6,0-8-3.4-8-8V40c0-4.6,3.4-8,8-8H312z M59.5,87c0,15.2,12.3,27.5,27.5,27.5 c15.2,0,27.5-12.3,27.5-27.5c0-15.2-12.3-27.5-27.5-27.5C71.8,59.5,59.5,71.8,59.5,87z M187,157h-1v-21h-45v152h47v-75 c0-19.8,3.9-39,28.5-39c24.2,0,24.5,22.4,24.5,40v74h47v-83.5c0-40.9-8.7-72-56.5-72C208.5,132.5,193.3,145.1,187,157z M64,288h47.5 V136H64V288z"/></svg></li>
        </a>
        
        
        
        <a href="mailto:?subject=Christopher%20Weaver%20-%20The%20Basics%20of%20Haskell.&amp;body=The%20Basics%20of%20Haskell%2c%20by%20Christopher%20Weaver%0a%0a%0a%2f%2flocalhost%3a52225%2fengineering%2fthe-basics-of-haskell%2f%0a" target="_blank" class="social-btn email">
          <li><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-mail" width="24" height="24" viewBox="0 0 416 288" fill="var(--color-primary)"><path d="m0 16v256 16h16 384 16v-16-256-16h-16-384-16zm347 16-139 92.5-139-92.5zm-148 125.5 9 5.5 9-5.5 167-111.5v210h-352v-210z"/></svg></li>
        </a>
      </ul>
    </div>
  </section>
  
        <div class="series">
          <p>Part of the <a href="//localhost:52225/series/haskell/">Haskell</a> series:</p>
          
          <ol>
              <li>The Basics of Haskell<span class="series-this-post">This post!</span>
                
              </li>
              <li>
                  <a href="//localhost:52225/engineering/lazy-evaluation-in-haskell/">Lazy Evaluation in Haskell</a>
                
              </li>
              <li>
                  <a href="//localhost:52225/engineering/creating-new-types-in-haskell/">Creating New Types in Haskell</a>
                
              </li>
          </ol>
        </div>
      
      
    </aside>
  </div>
</div>

    </main><footer>
  
  <div class="section footer">
    <p class="footer-copyright">&copy; 2025 &middot; 
      <a href="//localhost:52225/">Christopher Weaver</a>
      
    </p>
    
      <div class="footer-socials">
        
<div class="social-links">
  <ul class="social-icons">
    
    

    
    

    
    
    <li>
      <a href="https://github.com/crweaver225" target="_blank" rel="noopener" aria-label="Visit Github profile" class="social-btn github">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-github" width="24" height="24" viewBox="0 0 24 24" fill="var(--color-primary)"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
      </a>
    </li>
    

    
    

    
    
    <li>
      <a href="https://www.linkedin.com/in/christopher-weaver" target="_blank" rel="noopener" aria-label="Visit LinkedIn profile" class="social-btn linkedin">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-linkedin" width="24" height="24" viewBox="0 0 352 352" fill="var(--color-primary)"><path d="M0,40v272c0,21.9,18.1,40,40,40h272c21.9,0,40-18.1,40-40V40c0-21.9-18.1-40-40-40H40C18.1,0,0,18.1,0,40z M312,32 c4.6,0,8,3.4,8,8v272c0,4.6-3.4,8-8,8H40c-4.6,0-8-3.4-8-8V40c0-4.6,3.4-8,8-8H312z M59.5,87c0,15.2,12.3,27.5,27.5,27.5 c15.2,0,27.5-12.3,27.5-27.5c0-15.2-12.3-27.5-27.5-27.5C71.8,59.5,59.5,71.8,59.5,87z M187,157h-1v-21h-45v152h47v-75 c0-19.8,3.9-39,28.5-39c24.2,0,24.5,22.4,24.5,40v74h47v-83.5c0-40.9-8.7-72-56.5-72C208.5,132.5,193.3,145.1,187,157z M64,288h47.5 V136H64V288z"/></svg>
        </a>
    </li>
    

    
    
    <li>
      <a href="mailto:?to=crweaver225%40yahoo.com" target="_blank" class="social-btn email">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-mail" width="24" height="24" viewBox="0 0 416 288" fill="var(--color-primary)"><path d="m0 16v256 16h16 384 16v-16-256-16h-16-384-16zm347 16-139 92.5-139-92.5zm-148 125.5 9 5.5 9-5.5 167-111.5v210h-352v-210z"/></svg>
      </a>
    </li>
    
  </ul>
</div>

      </div>
    
  </div>
</footer>
  
  





  
  
  
    <script src="//localhost:52225/custom.js"></script>
  




  

<script src="//localhost:52225/main.js"></script>


</body>
</html>
