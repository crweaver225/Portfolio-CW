---
title: Why C++?
seo_title: Why C++?
summary: 
description: 
slug: Why C++
author: Christopher Weaver

draft: false
date: 2023-12-20T09:38:32-06:00
lastmod: 
expiryDate: 
publishDate: 

feature_image: cplusplus.jpeg
feature_image_alt: cplusplus.jpeg

categories:
- Engineering
tags:
- C++
series:
- C++

toc: true
related: true
social_share: true
newsletter: false
disable_comments: false
---

I have always been of the opinion that it is incumbent upon everyone to discover their 'thing'. The niche that helps establish one's self of identify and to help ward off the existential crises that eventually comes for us all. This can be anything. Anything at all. Bowling, volunteering, consuming and critiquing film and movies, gardening, wood working, baking. I could go on forever. For me, the first time I truly found my 'thing' and everything started to click was when I read Gottfried Leibniz in his Discourse on Metaphysics. It was a rigorous and intellectually stimulating attempt to better understand reality. His argument did not take shortcuts. It was not watered down for a general audience. For those not versed in the literature, it seemed like a random intellectual activity devoid of any greater context or meaning that could make it useful. But upon further evaluation you would find that this was a small part of a larger collection of foundational ideas used to build a systematic philosophical understanding of the world. 

Unfortunately for me, reading books on ontology has never amounted to much of a paycheck. The good news though is that a lot of what intrigued me about philosophy also was to be found in technology and engineering. I remember vividly during my first visit to disney world in 2000. We were in line at the Star Wars ride at Hollywood Studios and surrounded by robotic animatronics. I was enthralled. How did they work? What sort of crazy mechanisms made them tick? What was it like to be a robot? Were they conscious? What would it feel like to have such a systematic and rigorous intellect? How could would it be to be able to digitally access the world around you. These feats of engineering were systematic in how they worked and for me, ontologically interesting. That line queue at Disney World set me down the path towards a career in engineering. Software engineering to be exact. 

I have respect for all software engineers whom employ a vast set of technologies to help the world solve problems. Any problem that sofware can help resolve requires its own unique technology stack. For most front end web browser work, javascript and its many frameworks is the clear and correct answer. Python is often the clear go to for data science projects. Even at times where a technology stack is used in a way that is not ideal, it is often the best choice when considering all factors. A company building out their backend in ColdFusion may not be ideal in 2024, but if the company has decades of infrastructure already built out in the language, it is not clear that the organization should move away from continuing to use the stack it has. Sometimes continual development in a flawed tech stack makes more business sense than undertaking the massive task of migrating. Choices must be made by every software engineer on what tools to use, and over time most of us will find our niche. We will develop expertise in a specific set of tools and generally find careers that leverage these exact tools to solve problems. 

Almost from the moment I began doing software development, something about C++ intruigued me. The age of the language connected itself to computing from the 1970's and 1980's which I have always found to be a fascinating era of computing. The language name portrayed seriousness, being a derivative of the C programming language. This is in contrast to other languages like Python (named after the British comedy troupe), or Swift and Go which I believe are meant to signal that the language is easy and quick learn and employ. But mostly what I loved about C++ was the implications of why you would choose it for a project. C++ is not an easy language, and even for those who are seasoned in using it, development is not fast. You do not choose C++ for the speed or ease of development, you choose it because you want optimal code that obsessively focuses on computing algorithms as quickly as possible with a minimal memory footprint. For most languages, the goal is to build something that works and operates at reasonable runtimes. And this makes sense. For most projects, the runtime of Java, C#, Python and all other comparable langauge is usually more than sufficient for the problem they are trying to solve. But for C++, building something that works is not good enough. In C++, you also need your code to have optimal runtime performance. You should be thinking about different ways to cut milliseconds off performance where possible. You should be evaluating if a bit vector should be used over a vector of booleans to save on how many bytes are used in a data container. You should be benchmarking the performance of different implimentations in order to find the best one. If this is not the case, you probably should be choosing a different language. You do not choose C++ because it is an easy language to work with, you choose it because the project itself requires the types of performance C++ can offer. This is what makes the language so intriguing to me. 

To bring this full circle, I find parralells between the C++ programming language and what I found to be so profound about Gottfried Leibniz. Both Liebniz and C++ set off to tackle hard problems. One to understand the underlying nature of reality and the other to build software that can handle the most challenging tasks as efficiently as possible. Liebniz wrote complex papers that were unapologetic in the way they were pursued. Difficult problems often require difficult solutions. C++ has a complex syntax, partially from decades of growth and a desire to remain backward compatible, but also because it needs this complexity in order to tackle complex problems. It is these problems I want to help contribute to solving. And it is why I choose C++. 